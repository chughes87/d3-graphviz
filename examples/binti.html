<!DOCTYPE html>
<meta charset="utf-8">

<body>
    <script src="../node_modules/d3/dist/d3.js"></script>
    <script src="../node_modules/@hpcc-js/wasm/dist/index.min.js"></script>
    <script src="../build/d3-graphviz.js"></script>
    <script src="../dotfiles/binti-schema.js"></script>
    <button onclick="toggleBody()">toggle body</button>
    <button onclick="toggleDebugMode()">toggle debug mode</button>
    <div id="graph" style="text-align: center;"></div>
    <!-- <script src="./binti.js"> -->
<script>
   /*
 * TODOS
 * toggle body of just highlighted node
 * list inclusions/exclusions on the top
 * add UI guide
 * integrate NextJS
 * add search box
 * Dark mode
 */

function KeyPress(e) {
  var evtobj = window.event? event : e
  if (evtobj.keyCode == 90 && evtobj.metaKey && !evtobj.shiftKey) {
    history.back()
  }
  if (evtobj.keyCode == 90 && evtobj.metaKey && evtobj.shiftKey) {
    history.forward()
  }

  if (evtobj.key == 'Backspace') {
    excludedNodes = [...excludedNodes, ...selectedNodes]

    debugMode ? render() : redirect(focusedNodes, excludedNodes, includeBody, highlightedNode);
  }
}

document.onkeydown = KeyPress;

let margin = 0; // to avoid scrollbars

const urlSearchParams = new URLSearchParams(window.location.search);
const params = Object.fromEntries(urlSearchParams.entries());

let includeBody = params.includeBody === "true";
let focusedNodes = params.focusedNodes ? params.focusedNodes.split(",") : [];
let excludedNodes = params.excludedNodes ? params.excludedNodes.split(",") : [];
let selectedNodes = [];
let highlightedEdges = [];
let highlightedNode = params.highlightedNode;
let debugMode = false;

const nodeRegex = /\n(["\w:]+) \[([^}]|\n)+\}>\];/g;
const edgeRegex = /\n *(["\w:]+) -> (["\w:]+).*/g;

function toggleDebugMode () {
  debugMode = !debugMode;
}

function toggleBody() {
  // redirect(focusedNodes, excludedNodes, !includeBody, highlightedNode);
  includeBody = !includeBody
  render()
}

const redirect = (focusedNodes, excludedNodes, includeBody, highlightedNode) =>
  window.location.assign(
    buildQueryString(focusedNodes, excludedNodes, includeBody, highlightedNode)
  );

const buildQueryString = (
  focusedNodes,
  excludedNodes,
  includeBody,
  highlightedNode
) =>
  "?" +
  Object.entries({
    focusedNodes,
    excludedNodes,
    includeBody: [includeBody],
    highlightedNode: [highlightedNode],
  })
    .filter(([_, nodeNames]) => nodeNames.length)
    .map(([nodeType, nodeNames]) => [nodeType, nodeNames.join(",")])
    .map((kv) => kv.join("="))
    .join("&");

const cleanString = s => {
  return s && typeof s === "string" ? s.replaceAll('"','').trim() : s
};

const getEdgeMetaData = (node) => {
  const value = node.value;
  return {
    value: value[0],
    from: cleanString(value[1]),
    to: cleanString(value[2]),
  };
};

const getNodeMetaData = (node) => {
  const value = node.value;
  return {
    value: value[0],
    name: cleanString(value[1]),
  };
};

const extractDataFromIterator = (iter, getData) => {
  const data = [];
  let node = iter.next();
  while (!node.done) {
    data.push(getData(node));
    node = iter.next();
  }

  return data;
};

const generateMetaData = (src) => {
  const metaData = { nodes: [], edges: [] };
  const nodeIter = dotSrc.matchAll(nodeRegex);
  metaData.nodes = extractDataFromIterator(nodeIter, getNodeMetaData);
  const edgeIter = dotSrc.matchAll(edgeRegex);
  metaData.edges = extractDataFromIterator(edgeIter, getEdgeMetaData);

  return metaData;
};

const buildDot = ({ edges, nodes }) => {
  const header = `digraph Binti {
rankdir = "LR"
ranksep = "0.5"
nodesep = "0.4"
pad = "0.4,0.4"
margin = "0,0"
concentrate = "true"
labelloc = "t"
fontsize = "13"
fontname = "Arial Bold"
splines = "spline"
node[ shape  =  "Mrecord" , fontsize  =  "10" , fontname  =  "Arial" , margin  =  "0.07,0.05" , penwidth  =  "1.0"]
edge[ fontname  =  "Arial" , fontsize  =  "7" , dir  =  "both" , arrowsize  =  "0.9" , penwidth  =  "1.0" , labelangle  =  "32" , labeldistance  =  "1.8"]
rankdir = "TB"
label = "BintiFamily domain model\n\n"
`;

  return `
${header}\n
${includeBody ? nodes.map((n) => n.value).join("\n") : ""}
${edges.map((e) => e.value).join("\n")}
}`;
};

const filterData = ({ nodes, edges }, focusedNodes, excludedNodes) => {
  if (!focusedNodes.length) {
    return { nodes, edges };
  }
  const relatedEdges = edges.filter(
    (e) =>
      (focusedNodes.includes(e.from) || focusedNodes.includes(e.to)) &&
      !(excludedNodes.includes(e.from) || excludedNodes.includes(e.to))
  );
  const relatedNodes = relatedEdges.map((e) =>
    [e.from, e.to].find(
      (name) => !focusedNodes.includes(name) && !excludedNodes.includes(name)
    )
  );

  return {
    nodes: nodes.filter(
      (n) => focusedNodes.includes(n.name) || !!relatedNodes.includes(n.name)
    ),
    edges: relatedEdges,
  };
};

const metaData = generateMetaData();

const buildData = (focusedNodes, excludedNodes) => {
  const selectedData = filterData(metaData, focusedNodes, excludedNodes);
  return buildDot(selectedData);
};

function render() {
  initApp(buildData(focusedNodes, excludedNodes));
}

let graphviz = d3
  .select("#graph")
  .graphviz({ useWorker: true })
  .on("initEnd", render);

function initApp(src) {
  graphviz
    .attributer(attributer)
    // .transition(() => d3.transition().duration(1000))
    .renderDot(src, registerEventHandlers);
}

function attributer(datum, index, nodes) {
  let selection = d3.select(this);
  if (datum.tag == "svg") {
    let width = window.innerWidth - margin;
    let height = window.innerHeight - margin;
    let unit = "px";
    selection.attr("width", width + unit).attr("height", height + unit);
    datum.attributes.width = width + unit;
    datum.attributes.height = height + unit;
  }
}

function highlightNode(title) {
  highlightedEdges.map((s) =>
    s.attr("stroke", "black").attr("stroke-width", "1px")
  );
  if (highlightedNode == title) {
    highlightedEdges = [];
    highlightedNode = null;
    return;
  }
  highlightedNode = title || highlightedNode;
  const edges = d3
    .selectAll(".edge")
    .filter((x) =>
      x.key.match(new RegExp(`(^${highlightedNode}->|->${highlightedNode}$)`))
    );
  const path = edges
    .selectAll("path")
    .attr("stroke", "red")
    .attr("stroke-width", "5px");
  highlightedEdges = [path];
}

function registerEventHandlers() {
  let nodes = d3.selectAll(".node");
  let edges = d3.selectAll(".edge");

  if (highlightedNode && highlightedNode.length) {
    highlightNode();
  }

  nodes
    .filter((x) => focusedNodes.includes(x.key))
    .attr("stroke-width", "2px");

  nodes
    .filter((x) => selectedNodes.includes(x.key))
    .attr("fill", "lightgrey");
  // click outside of nodes
  // d3.select(document).on("click", function() { })

  // keyup outside of nodes
  // d3.select(document).on("keyup", function() { })

  // move
  // d3.select(document).on("mousemove", (event) => { })

  // click and mousedown on nodes
  nodes.on("click", function (event) {
    event.preventDefault();
    title = this.children[0].textContent;
    if (event.shiftKey) {
      highlightNode(title)
      return
    }
    else if (event.metaKey) {
      selectedNodes.push(title);
        render();
      return;
    }
    else if (!focusedNodes.includes(title)) {
      focusedNodes.push(title);
      initApp(buildData(focusedNodes, excludedNodes))
    } else {
      focusedNodes = focusedNodes.filter(n => n !== title)
    }

    debugMode ? render() : redirect(focusedNodes, excludedNodes, includeBody, highlightedNode);
  });

  // double-click on nodes
  // nodes.on("dblclick", function() { })

  // right-click on nodes
  nodes.on("contextmenu", function (event) {
    event.preventDefault();
    title = this.children[0].textContent;
    if (focusedNodes.includes(title)) {
      focusedNodes = focusedNodes.filter((n) => n != title);
    }
    excludedNodes.push(title);
    debugMode ? render() : redirect(focusedNodes, excludedNodes, includeBody, highlightedNode);
  });

  // click and mousedown on edges
  // edges.on("click mousedown", function() { })

  // right-click outside of nodes
  // d3.select(document).on("contextmenu", function() { })
}
</script>
</body>